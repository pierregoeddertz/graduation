<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Karte – GitHub Pages (Query-Param Bilder)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; }
    canvas { width: 100%; height: 100%; display: block; touch-action: none; }
  </style>
</head>
<body>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // ===== Konfiguration =====
    const FRONT_SRC = './assets/front.png';
    const DEFAULT_BACK_SRC = './assets/backs/back-01.png';

    // Query-Params: ?guest=7  ODER  ?back=backs/custom.png
    const q = new URLSearchParams(location.search);
    const guest = q.get('guest');
    const backParam = q.get('back');
    const backSrc = backParam
      ? (backParam.startsWith('./') || backParam.startsWith('http') ? backParam : `./assets/${backParam}`)
      : (guest ? `./assets/backs/back-${String(guest).padStart(2,'0')}.png` : DEFAULT_BACK_SRC);

    // ===== Renderer =====
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 1); // Hintergrund schwarz
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    // ===== Scene & Camera =====
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
    let zoomZ = 4; const Z_MIN = 2.4, Z_MAX = 7.6;
    function setZoom(z){ zoomZ = THREE.MathUtils.clamp(z, Z_MIN, Z_MAX); }
    camera.position.set(0, 0, zoomZ);

    // ===== Beleuchtung (extrem weich und streuend) =====
    // sanftes "globales" Licht: Himmel/Erde
    const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.35);
    scene.add(hemi);

    // Key-Spot: extrem breiter Kegel, volle Penumbra, langsames Decay → maximal streuend
    const key = new THREE.SpotLight(0xffffff, 1.5, 60.0, /*angle*/ 1.7, /*penumbra*/ 1.0, /*decay*/ 1.0);
    key.position.set(1.6, 1.2, 2.2);
    key.target.position.set(0, 0.05, 0);
    scene.add(key); scene.add(key.target);

    // Fill-Spot: noch breiter und schwächer
    const fill = new THREE.SpotLight(0xffffff, 1.0, 60.0, 1.75, 1.0, 1.0);
    fill.position.set(-1.4, 0.8, 1.8);
    fill.target.position.set(0, 0.0, 0);
    scene.add(fill); scene.add(fill.target);

    // Sehr sanfter Rim-Licht von hinten
    const rim = new THREE.SpotLight(0xffffff, 0.45, 60.0, 1.3, 1.0, 1.0);
    rim.position.set(0.6, 1.0, -2.2);
    rim.target.position.set(0, 0.0, 0);
    scene.add(rim); scene.add(rim.target);

    // ===== Karte (9 : 15.52) =====
    const W = 0.90;                 // Basisbreite
    const H = W * (15.52 / 9.0);    // exakte Ratio 9:15.52
    const thickness = 0.01;

    // Helle Kanten/Seitenfläche (statt Schwarz etwas grauer, um sie hervorzuheben)
    const edgeMat = new THREE.MeshStandardMaterial({
      color: 0x555555, // Hellgrau statt Schwarz für die Kanten
      metalness: 0.0,
      roughness: 0.8 // leicht matt
    });

    const loader = new THREE.TextureLoader();
    loader.crossOrigin = 'anonymous';

    function makeFaceMat(url){
      const tex = loader.load(url);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 1;
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;

      // Weit gestreute, weiche Glanzlichter
      return new THREE.MeshPhysicalMaterial({
        map: tex,
        metalness: 0.0,
        roughness: 0.70,          // weicher/breiter
        clearcoat: 1.0,
        clearcoatRoughness: 0.28  // breitere Highlights
      });
    }

    const frontMat = makeFaceMat(FRONT_SRC);
    const backMat  = makeFaceMat(backSrc);

    // Reihenfolge: px, nx, py, ny, pz(front), nz(back)
    const mats = [edgeMat, edgeMat, edgeMat, edgeMat, frontMat, backMat];

    const cardMesh = new THREE.Mesh(new THREE.BoxGeometry(W, H, thickness), mats);
    const cardGroup = new THREE.Group(); cardGroup.add(cardMesh); scene.add(cardGroup);

    // ===== Math/Helpers =====
    const norm = (deg)=> THREE.MathUtils.euclideanModulo(deg + 180, 360) - 180; // [-180,180)
    const shortest = (from,to)=> norm(to - from);
    const isBack = (y)=> Math.abs(norm(y)) > 179.5; // ~180°
    const nearestFrontBack = (y)=> { const n=norm(y); return Math.abs(n)<=90?0:(n>0?180:-180); };
    const nearestCardinal = (z)=> { const n = THREE.MathUtils.euclideanModulo(z,360); const opts=[0,90,180,270]; let best=0,b=1e9; for(const o of opts){ const d=Math.min(Math.abs(n-o),Math.abs(n-o+360),Math.abs(n-o-360)); if(d<b){b=d;best=o;} } return best; };

    // ===== State =====
    let angleX = 0, angleY = 0, angleZ = 0;
    let animating = false;

    // Gesten-Parameter
    const Y_SENS = 0.65;
    const X_SENS = 0.18;
    const X_LIMIT = 20;
    const ROT_SENS_Z = 1.0;

    // ===== Render =====
    function render(){
      camera.position.z += (zoomZ - camera.position.z) * 0.18; // sanfter Zoom

      // Winkel clamp/normalize
      angleY = norm(angleY); angleZ = norm(angleZ);
      angleX = THREE.MathUtils.clamp(angleX, -X_LIMIT, X_LIMIT);

      cardGroup.rotation.set(
        THREE.MathUtils.degToRad(angleX),
        THREE.MathUtils.degToRad(angleY),
        THREE.MathUtils.degToRad(angleZ)
      );

      renderer.render(scene, camera);
    }
    renderer.setAnimationLoop(render);

    // ===== Snapping =====
    function snapAfterDrag(){
      const yT = nearestFrontBack(angleY);
      const zT = isBack(yT) ? angleZ : 0; // Front immer Z=0
      animateTo({ y: yT, x: 0, z: zT });
    }
    function snapAfterRotate(){
      const yT = nearestFrontBack(angleY);
      const zT = isBack(yT) ? nearestCardinal(angleZ) : 0; // Back: 0/90/180/270
      animateTo({ y: yT, x: 0, z: zT });
    }
    function animateTo({ y, x, z }){
      animating = true;
      const sY=angleY,sX=angleX,sZ=angleZ;
      const dY=shortest(sY,y), dX=shortest(sX,x), dZ=shortest(sZ,(z??sZ));
      const dur=420, t0=performance.now();
      (function tick(t){
        const p=Math.min(1,(t-t0)/dur);
        const e=1-Math.pow(1-p,3);
        angleY=sY+dY*e; angleX=sX+dX*e; angleZ=sZ+dZ*e;
        if(p<1) requestAnimationFrame(tick); else { angleY=y; angleX=x; angleZ=(z??sZ); if(!isBack(angleY)) angleZ=0; animating=false; }
      })(performance.now());
    }

    // ===== Gesten (Pointer) =====
    const el = renderer.domElement;
    const pointers = new Map();
    let isDragging=false, isRotating=false, didRotate=false;
    let last = { x:0, y:0 };
    let gStartAngle=0, gStartZ=0, pinchStart=0, pinchZoom0=zoomZ;
    const angleBetween=(a,b)=> Math.atan2(b.y-a.y,b.x-a.x);
    const dist=(a,b)=> Math.hypot(a.x-b.x,a.y-b.y);

    el.addEventListener('pointerdown', (e)=>{
      if (animating) return;
      el.setPointerCapture(e.pointerId);
      pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
      if(pointers.size===1){ isDragging=true; isRotating=false; didRotate=false; last.x=e.clientX; last.y=e.clientY; }
      else if(pointers.size===2){ const [p1,p2]=[...pointers.values()]; gStartAngle=angleBetween(p1,p2); gStartZ=angleZ; pinchStart=dist(p1,p2); pinchZoom0=zoomZ; isDragging=false; isRotating=true; didRotate=false; }
    });

    el.addEventListener('pointermove', (e)=>{
      if(!pointers.has(e.pointerId) || animating) return;
      pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
      if(pointers.size===1 && isDragging){
        const dx=e.clientX-last.x, dy=e.clientY-last.y; last.x=e.clientX; last.y=e.clientY;
        angleY += dx * Y_SENS;
        angleX = THREE.MathUtils.clamp(angleX + dy * X_SENS, -X_LIMIT, X_LIMIT);
      } else if(pointers.size===2 && isRotating){
        const [p1,p2]=[...pointers.values()];
        const d = dist(p1,p2); if (pinchStart>0){ const scale=d/pinchStart; setZoom(pinchZoom0 + (1 - scale) * 3.0); }
        const cur = angleBetween(p1,p2);
        const deltaDeg = THREE.MathUtils.radToDeg(cur - gStartAngle);
        if (isBack(angleY)) { angleZ = norm(gStartZ + deltaDeg * ROT_SENS_Z); if(Math.abs(deltaDeg)>0.5) didRotate = true; }
      }
    });

    function endPointer(e){
      if(!pointers.has(e.pointerId)) return;
      try{ el.releasePointerCapture(e.pointerId); }catch{}
      pointers.delete(e.pointerId);
      if(pointers.size===0){ const wasRotate = didRotate; isDragging=false; isRotating=false; didRotate=false; if (wasRotate) snapAfterRotate(); else snapAfterDrag(); }
      else if(pointers.size===1){ const only=[...pointers.values()][0]; last.x=only.x; last.y=only.y; isDragging=true; isRotating=false; }
    }

    el.addEventListener('pointerup', endPointer);
    el.addEventListener('pointercancel', endPointer);
    el.addEventListener('pointerleave', endPointer);

    // Trackpad/Mausrad Zoom
    el.addEventListener('wheel', (e)=>{ const delta=(e.deltaY||0)*0.0015; setZoom(zoomZ + delta * 3.0); e.preventDefault(); }, { passive:false });

    // Resize
    window.addEventListener('resize', ()=>{
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
