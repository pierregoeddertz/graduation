<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Karte – Snap Front/Back + Rotate-Geste Snap 4 Seiten</title>
  <style>
    html, body { height: 100%; margin: 0; background: #fff; }
    canvas { width: 100%; height: 100%; display: block; touch-action: none; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0,0.2,4);

    const amb = new THREE.AmbientLight(0xffffff, 0.15); scene.add(amb);
    const key = new THREE.DirectionalLight(0xffffff, 0.6); key.position.set(1, 1.2, 1); scene.add(key);
    const rim = new THREE.DirectionalLight(0xffffff, 0.25); rim.position.set(-1, -0.3, -1); scene.add(rim);

    const ASPECT_W = 9, ASPECT_H = 15.52; // Breite:Höhe
    const cardH = 1.5;                          // Basis-Höhe (beliebig skalierbar)
    const cardW = cardH * (ASPECT_W / ASPECT_H); // ergibt 9:15.52-Format
    const thickness = 0.01;
    // --- Materialien: Kante dunkel, Front/Back als Texturen über Query-Param ---
    const sideMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.3, roughness: 0.6 });

    // GitHub Pages: Bilder unter ./assets/
    const FRONT_SRC = './assets/front.png';
    const DEFAULT_BACK_SRC = './assets/backs/back-01.png';

    // Query: ?guest=01..14  ODER  ?back=backs/name.png
    const q = new URLSearchParams(location.search);
    const guest = q.get('guest');
    const backParam = q.get('back');
    const backSrc = backParam
      ? (backParam.startsWith('./') || backParam.startsWith('http') ? backParam : `./assets/${backParam}`)
      : (guest ? `./assets/backs/back-${String(guest).padStart(2,'0')}.png` : DEFAULT_BACK_SRC);

    const loader = new THREE.TextureLoader();

    function faceMat(url){
      const tex = loader.load(url);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 1;
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      return new THREE.MeshBasicMaterial({ map: tex });
    }

    const frontMat = faceMat(FRONT_SRC);
    const backMat  = faceMat(backSrc);
    // Back-UV-Korrektur: horizontal spiegeln, damit Schrift/Design nicht gespiegelt wirkt
    backMat.map.wrapS = THREE.RepeatWrapping;
    backMat.map.repeat.x = -1;
    backMat.map.offset.x = 1;
    const mats=[sideMat,sideMat,sideMat,sideMat,frontMat,backMat];
    const cardMesh=new THREE.Mesh(new THREE.BoxGeometry(cardW,cardH,thickness),mats);

    const cardGroup=new THREE.Group();
    cardGroup.add(cardMesh);
    scene.add(cardGroup);

    let angleX=0, angleY=0, angleZ=0;
    let isDragging=false; let last={x:0,y:0};
    let isRotating=false; // für 2-Finger Rotate

    function render(){
      cardGroup.rotation.set(THREE.MathUtils.degToRad(angleX),THREE.MathUtils.degToRad(angleY),THREE.MathUtils.degToRad(angleZ));
      renderer.render(scene,camera);
    }
    renderer.setAnimationLoop(render);

    function shortestDelta(target,current){
      let d=target-current;
      d=((d+180)%360)-180;
      return d;
    }

    function snapFrontBack(){
      const n=((angleY%360)+360)%360;
      const yTarget=(n<90)? angleY-n : (n<270? angleY+(180-n) : angleY+(360-n));
      animateTo(yTarget,0,0);
    }

    function snapFourSides(){
      const yTarget=180;
      const zTarget=Math.round(angleZ/90)*90;
      animateTo(yTarget,0,zTarget);
    }

    function animateTo(yT,xT,zT){
      const sY=angleY,sX=angleX,sZ=angleZ;
      const dY=shortestDelta(yT,sY);
      const dX=shortestDelta(xT,sX);
      const dZ=shortestDelta(zT,sZ);
      const dur=420,t0=performance.now();
      function tick(t){
        const p=Math.min(1,(t-t0)/dur);
        const e=1-Math.pow(1-p,3);
        angleY=sY+dY*e;
        angleX=sX+dX*e;
        angleZ=sZ+dZ*e;
        render();
        if(p<1) requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    }

    const el=renderer.domElement;
    el.addEventListener('pointerdown',e=>{
      isDragging=true;last.x=e.clientX;last.y=e.clientY;el.setPointerCapture(e.pointerId);
    });
    el.addEventListener('pointermove',e=>{
      if(!isDragging||isRotating)return;
      const dx=e.clientX-last.x,dy=e.clientY-last.y;last.x=e.clientX;last.y=e.clientY;
      angleY+=dx*0.25; // sensitiver -> schneller
      angleX+=dy*0.25;
    });
    el.addEventListener('pointerup',e=>{
      if(!isDragging)return;isDragging=false;el.releasePointerCapture(e.pointerId);
      if(!isRotating) snapFrontBack();
    });

    let pointers=new Map(); let rotateStartAngle=0; let rotateStartZ=0;
    function angleBetween(a,b){return Math.atan2(b.y-a.y,b.x-a.x);}

    el.addEventListener('pointerdown',e=>{
      pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
      if(pointers.size===2){
        isRotating=true;
        const [p1,p2]=[...pointers.values()];
        rotateStartAngle=angleBetween(p1,p2);
        rotateStartZ=angleZ;
      }
    });
    el.addEventListener('pointermove',e=>{
      if(!pointers.has(e.pointerId))return;
      pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
      if(pointers.size===2){
        const [p1,p2]=[...pointers.values()];
        const curr=angleBetween(p1,p2);
        const delta=THREE.MathUtils.radToDeg(curr-rotateStartAngle);
        angleZ=rotateStartZ+delta;
      }
    });
    el.addEventListener('pointerup',e=>{
      pointers.delete(e.pointerId);
      if(pointers.size<2 && isRotating){
        isRotating=false;
        snapFourSides();
      }
    });

    window.addEventListener('resize',()=>{
      renderer.setSize(window.innerWidth,window.innerHeight);
      camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
