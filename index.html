<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Karte – Snap Front/Back + Rotate-Geste Snap 4 Seiten</title>
  <style>
    html, body { height: 100%; margin: 0; background: #fff; }
    canvas { width: 100%; height: 100%; display: block; touch-action: none; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0,0.2,4);

    const amb = new THREE.AmbientLight(0xffffff, 0.15); scene.add(amb);
    const key = new THREE.DirectionalLight(0xffffff, 0.6); key.position.set(1, 1.2, 1); scene.add(key);
    const rim = new THREE.DirectionalLight(0xffffff, 0.25); rim.position.set(-1, -0.3, -1); scene.add(rim);

    const cardW=1.0, cardH=1.5, thickness=0.01;
    const sideMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.3, roughness: 0.6 });
    const frontMat = new THREE.MeshStandardMaterial({ color: 0x0b0b0b, metalness: 0.2, roughness: 0.65 });
    const backMat  = new THREE.MeshStandardMaterial({ color: 0x0b0b0b, metalness: 0.2, roughness: 0.65 });
    const mats=[sideMat,sideMat,sideMat,sideMat,frontMat,backMat];
    const cardMesh=new THREE.Mesh(new THREE.BoxGeometry(cardW,cardH,thickness),mats);

    const cardGroup=new THREE.Group();
    cardGroup.add(cardMesh);
    scene.add(cardGroup);

    let angleX=0, angleY=0, angleZ=0;
    let isDragging=false; let last={x:0,y:0};
    let isRotating=false; // für 2-Finger Rotate

    function render(){
      cardGroup.rotation.set(THREE.MathUtils.degToRad(angleX),THREE.MathUtils.degToRad(angleY),THREE.MathUtils.degToRad(angleZ));
      renderer.render(scene,camera);
    }
    renderer.setAnimationLoop(render);

    function shortestDelta(target,current){
      let d=target-current;
      d=((d+180)%360)-180;
      return d;
    }

    function snapFrontBack(){
      const n=((angleY%360)+360)%360;
      const yTarget=(n<90)? angleY-n : (n<270? angleY+(180-n) : angleY+(360-n));
      animateTo(yTarget,0,0);
    }

    function snapFourSides(){
      const yTarget=180;
      const zTarget=Math.round(angleZ/90)*90;
      animateTo(yTarget,0,zTarget);
    }

    function animateTo(yT,xT,zT){
      const sY=angleY,sX=angleX,sZ=angleZ;
      const dY=shortestDelta(yT,sY);
      const dX=shortestDelta(xT,sX);
      const dZ=shortestDelta(zT,sZ);
      const dur=420,t0=performance.now();
      function tick(t){
        const p=Math.min(1,(t-t0)/dur);
        const e=1-Math.pow(1-p,3);
        angleY=sY+dY*e;
        angleX=sX+dX*e;
        angleZ=sZ+dZ*e;
        render();
        if(p<1) requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    }

    const el=renderer.domElement;
    el.addEventListener('pointerdown',e=>{
      isDragging=true;last.x=e.clientX;last.y=e.clientY;el.setPointerCapture(e.pointerId);
    });
    el.addEventListener('pointermove',e=>{
      if(!isDragging||isRotating)return;
      const dx=e.clientX-last.x,dy=e.clientY-last.y;last.x=e.clientX;last.y=e.clientY;
      angleY+=dx*0.25; // sensitiver -> schneller
      angleX+=dy*0.25;
    });
    el.addEventListener('pointerup',e=>{
      if(!isDragging)return;isDragging=false;el.releasePointerCapture(e.pointerId);
      if(!isRotating) snapFrontBack();
    });

    let pointers=new Map(); let rotateStartAngle=0; let rotateStartZ=0;
    function angleBetween(a,b){return Math.atan2(b.y-a.y,b.x-a.x);}

    el.addEventListener('pointerdown',e=>{
      pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
      if(pointers.size===2){
        isRotating=true;
        const [p1,p2]=[...pointers.values()];
        rotateStartAngle=angleBetween(p1,p2);
        rotateStartZ=angleZ;
      }
    });
    el.addEventListener('pointermove',e=>{
      if(!pointers.has(e.pointerId))return;
      pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
      if(pointers.size===2){
        const [p1,p2]=[...pointers.values()];
        const curr=angleBetween(p1,p2);
        const delta=THREE.MathUtils.radToDeg(curr-rotateStartAngle);
        angleZ=rotateStartZ+delta;
      }
    });
    el.addEventListener('pointerup',e=>{
      pointers.delete(e.pointerId);
      if(pointers.size<2 && isRotating){
        isRotating=false;
        snapFourSides();
      }
    });

    window.addEventListener('resize',()=>{
      renderer.setSize(window.innerWidth,window.innerHeight);
      camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
