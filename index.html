<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Karte – Schwarz, Licht aktiv, hohe Texture-Qualität</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; }
    canvas { width: 100%; height: 100%; display: block; touch-action: none; background: #000; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { RoomEnvironment } from 'https://unpkg.com/three@0.160.0/examples/jsm/environments/RoomEnvironment.js';

    // ===== Renderer =====
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(0x000000, 1);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    renderer.physicallyCorrectLights = true;
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // ===== Scene & Camera =====
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0,0,4);

    // HDRI-ähnliche Umgebung für bessere Reflexe
    const pmrem = new THREE.PMREMGenerator(renderer);
    const env = new RoomEnvironment();
    const envMap = pmrem.fromScene(env, 0.04).texture; // weiche, hochwertige Umgebung
    scene.environment = envMap;

    // ===== Lights (wirken nun auf die Materialien) =====
    const amb = new THREE.AmbientLight(0xffffff, 0.18); // zartes Grundlicht
    const key = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set(1.2, 1.4, 1.0); key.castShadow = false;
    const rim = new THREE.DirectionalLight(0xffffff, 0.45); rim.position.set(-1.0, -0.2, -1.2);
    scene.add(amb, key, rim);

    // ===== Karte Geometrie (9:15.52) =====
    const ASPECT_W = 9, ASPECT_H = 15.52;
    const cardH = 1.5;
    const cardW = cardH * (ASPECT_W / ASPECT_H);
    const thickness = 0.01;

    // ===== Texturen laden (Front/Back) mit hoher Qualität =====
    const FRONT_SRC = './assets/front.png';
    const DEFAULT_BACK_SRC = './assets/backs/back-01.png';

    const q = new URLSearchParams(location.search);
    const guest = q.get('guest');
    const backParam = q.get('back');
    const backSrc = backParam
      ? (backParam.startsWith('./') || backParam.startsWith('http') ? backParam : `./assets/${backParam}`)
      : (guest ? `./assets/backs/back-${String(guest).padStart(2,'0')}.png` : DEFAULT_BACK_SRC);

    const loader = new THREE.TextureLoader();

    function loadTextureHQ(url){
      const tex = loader.load(url);
      tex.colorSpace = THREE.SRGBColorSpace;     // korrekte Farbdarstellung
      tex.generateMipmaps = true;                // Mipmaps für Schärfe in allen Distanzen
      tex.minFilter = THREE.LinearMipmapLinearFilter; // „trilinear filtering“
      tex.magFilter = THREE.LinearFilter;        // glattes Upscaling
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 16; // maximal
      tex.wrapS = THREE.ClampToEdgeWrapping;
      tex.wrapT = THREE.ClampToEdgeWrapping;
      return tex;
    }

    // Materialien: jetzt StandardMaterial mit map, damit Licht wirkt
    const sideMat = new THREE.MeshStandardMaterial({ color: 0x0b0b0b, metalness: 0.35, roughness: 0.6, envMapIntensity: 0.6 });

    const frontTex = loadTextureHQ(FRONT_SRC);
    const backTex  = loadTextureHQ(backSrc);
    // Back horizontal spiegeln, damit Schrift korrekt ist
    backTex.wrapS = THREE.RepeatWrapping; backTex.repeat.x = -1; backTex.offset.x = 1;

    const frontMat = new THREE.MeshStandardMaterial({ map: frontTex, metalness: 0.2, roughness: 0.65, envMapIntensity: 0.7 });
    const backMat  = new THREE.MeshStandardMaterial({ map: backTex,  metalness: 0.2, roughness: 0.65, envMapIntensity: 0.7 });

    const mats = [sideMat, sideMat, sideMat, sideMat, frontMat, backMat]; // px,nx,py,ny,pz(front),nz(back)
    const cardMesh = new THREE.Mesh(new THREE.BoxGeometry(cardW, cardH, thickness), mats);

    const cardGroup = new THREE.Group();
    cardGroup.add(cardMesh);
    scene.add(cardGroup);

    // ===== Interaktion (wie zuvor) =====
    let angleX=0, angleY=0, angleZ=0;
    let isDragging=false; let last={x:0,y:0};
    let isRotating=false;

    function render(){
      cardGroup.rotation.set(THREE.MathUtils.degToRad(angleX),THREE.MathUtils.degToRad(angleY),THREE.MathUtils.degToRad(angleZ));
      renderer.render(scene,camera);
    }
    renderer.setAnimationLoop(render);

    function shortestDelta(target,current){ let d=target-current; d=((d+180)%360)-180; return d; }

    function snapFrontBack(){
      const n=((angleY%360)+360)%360;
      const yTarget=(n<90)? angleY-n : (n<270? angleY+(180-n) : angleY+(360-n));
      animateTo(yTarget,0,0);
    }

    function snapFourSides(){
      const yTarget=180;
      const zTarget=Math.round(angleZ/90)*90;
      animateTo(yTarget,0,zTarget);
    }

    function animateTo(yT,xT,zT){
      const sY=angleY,sX=angleX,sZ=angleZ;
      const dY=shortestDelta(yT,sY);
      const dX=shortestDelta(xT,sX);
      const dZ=shortestDelta(zT,sZ);
      const dur=420,t0=performance.now();
      function tick(t){
        const p=Math.min(1,(t-t0)/dur);
        const e=1-Math.pow(1-p,3);
        angleY=sY+dY*e; angleX=sX+dX*e; angleZ=sZ+dZ*e;
        render();
        if(p<1) requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    }

    const el=renderer.domElement;
    el.addEventListener('pointerdown',e=>{ isDragging=true; last.x=e.clientX; last.y=e.clientY; el.setPointerCapture(e.pointerId); });
    el.addEventListener('pointermove',e=>{
      if(!isDragging||isRotating) return;
      const dx=e.clientX-last.x, dy=e.clientY-last.y; last.x=e.clientX; last.y=e.clientY;
      angleY+=dx*0.25; angleX+=dy*0.25;
    });
    el.addEventListener('pointerup',e=>{ if(!isDragging) return; isDragging=false; el.releasePointerCapture(e.pointerId); if(!isRotating) snapFrontBack(); });

    let pointers=new Map(); let rotateStartAngle=0; let rotateStartZ=0;
    function angleBetween(a,b){ return Math.atan2(b.y-a.y, b.x-a.x); }

    el.addEventListener('pointerdown',e=>{
      pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
      if(pointers.size===2){
        isRotating=true;
        const [p1,p2]=[...pointers.values()];
        rotateStartAngle=angleBetween(p1,p2);
        rotateStartZ=angleZ;
      }
    });
    el.addEventListener('pointermove',e=>{
      if(!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
      if(pointers.size===2){
        const [p1,p2]=[...pointers.values()];
        const curr=angleBetween(p1,p2);
        const delta=THREE.MathUtils.radToDeg(curr-rotateStartAngle);
        angleZ=rotateStartZ+delta;
      }
    });
    el.addEventListener('pointerup',e=>{
      pointers.delete(e.pointerId);
      if(pointers.size<2 && isRotating){ isRotating=false; snapFourSides(); }
    });

    window.addEventListener('resize',()=>{
      renderer.setSize(window.innerWidth,window.innerHeight);
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
